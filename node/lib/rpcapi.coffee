memoizeByHash = reqzure 'util/memoizeByHash'
InexorService = require 'rpcapi/InexorService'
Promise = require 'promise'
Path = require 'path'
Dir = require 'node-dir'
Fs = require 'fs'
F = require 'util/functional'
_ = require 'lodash'

# High Level interface for communicating with Inexor
#
# The module always exposes the singleton value
# TODO: Use Promises
# TODO: This should pretty much only expose raw cubescr
class InexorRpc
  # The singleton value;
  #
  # @see @getSingleton
  # @return [Inexor]
  @singleton_value: null

  # Get or create the singleton instance
  #
  # This is what the module exposes
  #
  # @return [Inexor] The singleton value
  @getSingleton: ->
    InexorRpc.singleton_value ||= new InexorRpc

  # List of the cubescript function bindings generated by @C
  # This is used for the purpose of binding them to THIS on
  # construction
  @cbs_generated: []

  # The underlying InexorService
  #
  # @return [InexorService]
  service: null

  # The messages; taken from @service.messages
  #
  # TODO: Type?
  messages: null

  # Create one
  #
  # @param [InexorService] @service The underlying service
  constructor: (@service = new InexorService) ->
    @messages = @service.messages

  # Call an RPC function
  #
  # @param [Variant<Function, String>] fun – Either the name
  #   of an RPC function to invoke or the function itself
  #   (from @service.*)
  # @params args... – And arguments to pass to the RPC
  #   function. Note that all the arguments should normally
  #   be Protobuf messages from @messages.*
  # @return The protobuf message instance returned by the
  #   call
  rpcCall: (fun, args...) ->
    fun = @service[fun] if _.isString(fun)
    new Promise (resolve, reject) =>
      fun args..., (a...) =>
        if a[0] instanceof Error
        then reject a[0]
        else resolve a...

  # Evaluate some cubescript in inexor
  #
  # @param [string] code The code to evaluate
  # @return [Promise<null, Int, Float, String>]
  #   The cubescript return value
  evalCubescript: (code, cb=->) =>
    msg = new @messages.Cubescript code: code
    @rpcCall('EvalCubescript', msg).then (val) =>
      m.s || m.i || m.f

  # TODO: Escape
  callCubescript: (fun, args...) =>
    @evalCubescript "result (#{fun} #{args.join(" ")})"

  # TODO: Escape
  getVariable: (name) =>
    @evalCubescript "result $#{name}"

  setVariable: (name, val) =>
    @callCubescript name, val

  # TODO: Escape
  setCubescripVariable: (name, val) =>
    @evalCubescript "#{name} = (#{val})"

  ## FS API
  # This assumes that inexor is running on the same machiene
  # in the same fs context
  
  getPackagedirs: _.memoize =>
    # TODO: handle missing data
    @callCubescript("getpackagedirs").then (data) =>
      data.split ":"

  getHomedir: (cb) =>
    @getPackagedirs.then _.first

  findMedia: memoizeByHash (mediafiles, cb) ->
    @getPackagedirs.then (packagedirs) =>
      files = _.flatten \
        _.map packagedirs, (dir) =>
          _.map mediafiles, (mediafile) =>
              Path.join dir, mediafile

      # Adapter for the (err, path/undefined) format
      exists_promises = _.map files, Promise.denodeify(Fs.exists)
      Promise.all exists_promises, (exist_v) ->
        files[_.indexOf exist_v, true]

  findImageMedia: (basenames) =>
    # TODO: Are those really all?
    # TODO: Create one central compendium for this kind of stuff
    suffixes = ["jpg", "png", "tiff", "gif"]
    @findImageMedia \
      _.flatten \
        _.map suffixes, (suffix) =>
          _.map basenames, (name) =>
            "#{name}.#{suffix}"

  listPackageFiles: _.memoize ->
    tree = Promise.denodeify Dir.paths
    @getPackagedirs().then (packagedirs) =>
      Promise.all (_.map packagedirs, tree), (trees) =>
        [].join trees

module.exports = InexorRpc.getSingleton()
